<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SST Compare - Earth Observation</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="%2300a2ff"/></svg>' />
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif;
    }
    
    #map {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a0a;
      z-index: 0;
    }
    
    /* Smooth image scaling for SST overlay */
    .sst-overlay-layer,
    .leaflet-image-layer {
      image-rendering: auto;
      image-rendering: -webkit-optimize-contrast;
      transition: opacity 0.2s ease;
    }
    
    .leaflet-control-zoom {
      border: 1px solid rgba(255, 255, 255, 0.15) !important;
      border-radius: 12px !important;
      overflow: hidden;
      background: rgba(15, 23, 42, 0.95) !important;
      backdrop-filter: blur(20px) !important;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4) !important;
    }

    /* Move zoom controls to bottom left */
    .leaflet-top.leaflet-left {
      top: auto !important;
      bottom: 20px !important;
      left: 20px !important;
    }
    
    .leaflet-control-zoom a {
      background: transparent !important;
      color: white !important;
      border: none !important;
      width: 40px !important;
      height: 40px !important;
      line-height: 40px !important;
      font-size: 20px !important;
      font-weight: 500 !important;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
    }
    
    .leaflet-control-zoom a:hover {
      background: rgba(59, 130, 246, 0.25) !important;
      transform: scale(1.05);
    }
    
    .leaflet-control-zoom a:active {
      transform: scale(0.95);
    }
    
    .leaflet-bar a:first-child {
      border-top-left-radius: 12px !important;
      border-top-right-radius: 12px !important;
    }
    
    .leaflet-bar a:last-child {
      border-bottom-left-radius: 12px !important;
      border-bottom-right-radius: 12px !important;
    }
    
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .animate-slide-in {
      animation: slideIn 0.5s ease-out;
    }
    
    .glass {
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .glass-light {
      background: rgba(30, 41, 59, 0.75);
      backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.15);
    }
  </style>
</head>
<body>
  <!-- Map Container -->
  <div id="map"></div>

  <!-- Top-left back button -->
  <div class="fixed top-3 left-3 z-[1000] md:top-4 md:left-4 animate-slide-in">
    <a href="/public/EARTH.html" 
       class="group relative w-11 h-11 md:w-12 md:h-12 rounded-full glass hover:glass-light text-white shadow-2xl transition-all duration-300 hover:scale-110 active:scale-95 flex items-center justify-center">
      <svg class="w-5 h-5 md:w-6 md:h-6 transition-transform group-hover:-translate-x-0.5" fill="currentColor" viewBox="0 0 24 24">
        <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
      </svg>
      <div class="absolute -top-1 -right-1 w-2.5 h-2.5 bg-gradient-to-r from-emerald-400 to-green-500 rounded-full animate-pulse"></div>
    </a>
  </div>

  <!-- Top Timeline Bar -->
  <div class="fixed top-3 left-1/2 -translate-x-1/2 z-[1000] w-[90vw] max-w-2xl md:top-4 animate-slide-in">
    <div class="glass rounded-xl px-3 py-2 md:px-4 md:py-2.5 shadow-2xl">
      <div class="flex items-center gap-2 md:gap-3">
        <!-- Date Inputs -->
        <div class="flex items-center gap-1.5 flex-1">
          <input id="fromDate" type="date" 
                 class="text-[11px] md:text-xs glass-light rounded-lg px-2 py-1.5 md:px-2.5 md:py-2 text-white border-none outline-none focus:ring-2 focus:ring-blue-500/50 transition w-24 md:w-28" />
          <svg class="w-3 h-3 text-gray-400 flex-shrink-0" fill="currentColor" viewBox="0 0 24 24">
            <path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"/>
          </svg>
          <input id="toDate" type="date" 
                 class="text-[11px] md:text-xs glass-light rounded-lg px-2 py-1.5 md:px-2.5 md:py-2 text-white border-none outline-none focus:ring-2 focus:ring-blue-500/50 transition w-24 md:w-28" />
        </div>
        
        <!-- Action Buttons -->
        <div class="flex items-center gap-1.5 md:gap-2">
          <button id="buildBtn" title="Build Animation"
                  class="group relative w-8 h-8 md:w-9 md:h-9 bg-gradient-to-r from-emerald-500 to-green-500 hover:from-emerald-400 hover:to-green-400 text-white rounded-lg transition-all duration-300 shadow-lg hover:shadow-emerald-500/30 hover:scale-110 active:scale-95 flex items-center justify-center">
            <svg class="w-4 h-4 md:w-4.5 md:h-4.5" fill="currentColor" viewBox="0 0 24 24">
              <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"/>
            </svg>
          </button>
          
          <button id="playBtn" title="Play/Pause Animation"
                  class="group relative w-8 h-8 md:w-9 md:h-9 bg-gradient-to-r from-blue-500 to-indigo-500 hover:from-blue-400 hover:to-indigo-400 text-white rounded-lg transition-all duration-300 shadow-lg hover:shadow-blue-500/30 hover:scale-110 active:scale-95 flex items-center justify-center">
            <svg id="playIcon" class="w-3.5 h-3.5 md:w-4 md:h-4" fill="currentColor" viewBox="0 0 24 24">
              <path d="M8 5v14l11-7z"/>
            </svg>
            <svg id="pauseIcon" class="w-3.5 h-3.5 md:w-4 md:h-4 hidden" fill="currentColor" viewBox="0 0 24 24">
              <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
            </svg>
          </button>

          <button id="resetBtn" title="Reset Animation"
                  class="group relative w-8 h-8 md:w-9 md:h-9 bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-400 hover:to-gray-500 text-white rounded-lg transition-all duration-300 shadow-lg hover:shadow-gray-500/30 hover:scale-110 active:scale-95 flex items-center justify-center">
            <svg class="w-3.5 h-3.5 md:w-4 md:h-4" fill="currentColor" viewBox="0 0 24 24">
              <path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/>
            </svg>
          </button>
          
          <button id="downloadBtn" title="Download"
                  class="group relative w-8 h-8 md:w-9 md:h-9 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-400 hover:to-pink-400 text-white rounded-lg transition-all duration-300 shadow-lg hover:shadow-purple-500/30 hover:scale-110 active:scale-95 flex items-center justify-center">
            <svg class="w-3.5 h-3.5 md:w-4 md:h-4" fill="currentColor" viewBox="0 0 24 24">
              <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
            </svg>
          </button>
        </div>
        
        <!-- Status (desktop only) -->
        <div class="hidden md:flex items-center gap-2 ml-2">
          <div class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>
          <span id="status" class="text-xs text-gray-300 whitespace-nowrap">Ready</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Top-right Layers button -->
  <div class="fixed top-3 right-3 z-[1000] md:top-4 md:right-4 animate-slide-in" style="animation-delay: 0.1s;">
    <button id="layersButton" 
            class="group relative w-11 h-11 md:w-12 md:h-12 rounded-full glass hover:glass-light text-white shadow-2xl transition-all duration-300 hover:scale-110 active:scale-95 flex items-center justify-center">
      <svg class="w-5 h-5 md:w-6 md:h-6 transition-transform group-hover:scale-110" fill="currentColor" viewBox="0 0 24 24">
        <path d="M12 2l9 4-9 4-9-4 9-4zm0 7l9 4-9 4-9-4 9-4zm0 7l9 4-9 4-9-4 9-4z"/>
      </svg>
      <div class="absolute -top-1 -right-1 w-2.5 h-2.5 bg-gradient-to-r from-cyan-400 to-blue-500 rounded-full animate-pulse"></div>
    </button>
  </div>

  <!-- Layers Panel -->
  <div id="layersPanel" class="hidden fixed top-2 right-2 z-[1001] w-[92vw] max-w-sm md:top-3 md:right-3 md:w-80 animate-slide-in">
    <div class="glass rounded-2xl shadow-2xl overflow-hidden">
      <!-- Header -->
      <div class="px-4 py-3 border-b border-white/10 flex items-center justify-between bg-gradient-to-r from-blue-500/10 to-purple-500/10">
        <div class="flex items-center gap-2">
          <div class="w-2 h-2 rounded-full bg-gradient-to-r from-fuchsia-400 to-violet-400 animate-pulse"></div>
          <h3 class="font-semibold text-sm text-white">Map Layers</h3>
        </div>
        <button id="layersClose" class="text-gray-400 hover:text-white transition-colors">
          <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
          </svg>
        </button>
      </div>
      
      <!-- Base Layer -->
      <div class="px-4 py-3 border-b border-white/10">
        <div class="flex items-center gap-2 mb-2">
          <div class="w-2 h-2 rounded-full bg-gradient-to-r from-blue-400 to-cyan-400"></div>
          <div class="text-xs font-semibold text-white">Base Layer</div>
        </div>
        <div class="flex items-center justify-between">
          <div class="text-xs text-gray-300">Blue Marble (NASA GIBS)</div>
          <span class="text-[10px] px-2 py-0.5 rounded-full bg-emerald-500/20 text-emerald-300 border border-emerald-500/30">Always On</span>
        </div>
      </div>

      <!-- Data Overlays -->
      <div class="px-4 py-3">
        <div class="flex items-center gap-2 mb-3">
          <div class="w-2 h-2 rounded-full bg-gradient-to-r from-purple-400 to-pink-400"></div>
          <div class="text-xs font-semibold text-white">Data Overlays</div>
        </div>
        
        <label class="group flex items-center justify-between gap-3 p-3 rounded-xl bg-gradient-to-r from-gray-800/50 to-gray-700/50 hover:from-gray-700/60 hover:to-gray-600/60 border border-white/5 hover:border-white/15 transition-all duration-300 cursor-pointer">
          <div class="flex items-center gap-2.5">
            <div class="w-8 h-8 rounded-lg bg-gradient-to-br from-cyan-500 to-blue-600 flex items-center justify-center shadow-lg">
              <svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 24 24">
                <path d="M17.66 11.2c-.23-.3-.51-.56-.77-.82-.67-.6-1.43-1.03-2.07-1.66C13.33 7.26 13 4.85 13.95 3c-.95.23-1.78.75-2.49 1.32-2.59 2.08-3.61 5.75-2.39 8.9.04.1.08.2.08.33 0 .22-.15.42-.35.5-.23.1-.47.04-.66-.12a.58.58 0 01-.14-.17c-1.13-1.43-1.31-3.48-.55-5.12C5.78 10 4.87 12.3 5 14.47c.06.5.12 1 .29 1.5.14.6.41 1.2.71 1.73 1.08 1.73 2.95 2.97 4.96 3.22 2.14.27 4.43-.12 6.07-1.6 1.83-1.66 2.47-4.32 1.53-6.6l-.13-.26c-.21-.46-.77-1.26-.77-1.26m-3.16 6.3c-.28.24-.74.5-1.1.6-1.12.4-2.24-.16-2.9-.82 1.19-.28 1.9-1.16 2.11-2.05.17-.8-.15-1.46-.28-2.23-.12-.74-.1-1.37.17-2.06.19.38.39.76.63 1.06.77 1 1.98 1.44 2.24 2.8.04.14.06.28.06.43.03.82-.33 1.72-.93 2.27z"/>
              </svg>
            </div>
            <div>
              <div class="text-xs font-medium text-white">Sea Surface Temp</div>
              <div class="text-[10px] text-gray-400">GHRSST MUR L4</div>
            </div>
          </div>
          <input id="sstLayer" type="checkbox" class="peer sr-only">
          <div class="relative w-11 h-6 rounded-full bg-gradient-to-r from-gray-600 to-gray-700 peer-checked:from-cyan-500 peer-checked:to-blue-500 transition-all duration-300 shadow-inner">
            <div class="absolute top-0.5 left-0.5 w-5 h-5 rounded-full bg-white shadow-lg transition-transform duration-300 peer-checked:translate-x-5"></div>
          </div>
        </label>
      </div>
    </div>
  </div>

  <!-- Loading Indicator -->
  <div id="loadingIndicator" class="hidden fixed bottom-4 left-4 z-[1000] glass rounded-xl px-4 py-3 shadow-2xl">
    <div class="flex items-center gap-3">
      <div class="w-5 h-5 border-2 border-blue-500/30 border-t-blue-500 rounded-full animate-spin"></div>
      <span id="loadingText" class="text-xs text-white font-medium">Loading...</span>
    </div>
  </div>

  <!-- Frame Count and Progress -->
  <div id="frameCountDisplay" class="fixed bottom-4 right-4 z-[1000] glass rounded-xl px-3 py-2 shadow-2xl max-w-xs">
    <div id="frameCount" class="text-xs text-white font-medium"></div>
    <div id="progressBar" class="hidden mt-2">
      <div class="w-full bg-gray-700 rounded-full h-1.5">
        <div id="progressFill" class="bg-blue-500 h-1.5 rounded-full transition-all duration-300" style="width: 0%"></div>
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  
  <script>
    // Global variables
    let map;
    let sstLayer = null;
    let animationFrames = [];
    let currentFrameIndex = 0;
    let animationInterval = null;
    let isPlaying = false;
    let savedMapView = null; // Store map view when building animation
    
    // Initialize map
    function initMap() {
      try {
        map = L.map('map', {
          center: [20, 0],
          zoom: 2,
          minZoom: 1,
          maxZoom: 8,
          zoomControl: true,
          attributionControl: false,
          worldCopyJump: false  // Disable jumping between world copies
        });
        
        // Add Blue Marble base layer
        L.tileLayer('https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/BlueMarble_ShadedRelief_Bathymetry/default/2025-10-02/GoogleMapsCompatible_Level8/{z}/{y}/{x}.jpeg', {
          maxZoom: 8,
          tileSize: 256,
          noWrap: true,  // Show only one copy of the world
          bounds: [[-85.0511, -180], [85.0511, 180]],  // Limit to valid world bounds
          attribution: 'NASA GIBS'
        }).addTo(map);
        
        updateStatus('Map Ready');
        console.log('Map initialized successfully');
      } catch (error) {
        console.error('Map initialization error:', error);
        updateStatus('Map Error');
      }
    }
    
    // Generate date array between two dates
    function getDateArray(startDate, endDate) {
      const dates = [];
      const start = new Date(startDate);
      const end = new Date(endDate);

      for (let date = new Date(start); date <= end; date.setDate(date.getDate() + 1)) {
        dates.push(new Date(date).toISOString().split('T')[0]);
      }

      return dates;
    }

    // Helper function to convert blob to base64 data URL
    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    // Build animation frames by fetching images for CURRENT map view
    async function buildAnimation() {
      const fromDate = document.getElementById('fromDate').value;
      const toDate = document.getElementById('toDate').value;

      if (!fromDate || !toDate) {
        alert('Please select both start and end dates.');
        return;
      }

      showLoading('Fetching images for current map view...');
      updateStatus('Fetching Images...');

      // Show progress bar
      const progressBar = document.getElementById('progressBar');
      const progressFill = document.getElementById('progressFill');
      if (progressBar && progressFill) {
        progressBar.classList.remove('hidden');
      }

      try {
        // Get all dates between from and to dates
        const dateArray = getDateArray(fromDate, toDate);
        animationFrames = [];

        console.log(`Fetching images for ${dateArray.length} dates`);

        // Get CURRENT map view bounds and size
        const bounds = map.getBounds();
        const size = map.getSize();
        
        // Store current view for consistent playback
        const viewBounds = {
          west: bounds.getWest(),
          south: bounds.getSouth(),
          east: bounds.getEast(),
          north: bounds.getNorth()
        };

        // Save map view state
        savedMapView = {
          center: map.getCenter(),
          zoom: map.getZoom(),
          bounds: viewBounds
        };

        // Use current map size for optimal resolution
        const imageWidth = Math.min(size.x * 2, 2048); // 2x for retina, max 2048
        const imageHeight = Math.min(size.y * 2, 2048);
        
        // BBOX in EPSG:4326 format: minLat,minLon,maxLat,maxLon
        const bbox = `${viewBounds.south},${viewBounds.west},${viewBounds.north},${viewBounds.east}`;

        console.log(`Fetching for current view: ${bbox} at ${imageWidth}x${imageHeight}px`);

        // Fetch complete static images for each date
        for (let i = 0; i < dateArray.length; i++) {
          const date = dateArray[i];

          try {
            // Construct WMS GetMap request for CURRENT VIEW
            const wmsUrl = `https://gibs.earthdata.nasa.gov/wms/epsg4326/best/wms.cgi?` +
              `SERVICE=WMS&REQUEST=GetMap&VERSION=1.3.0` +
              `&LAYERS=GHRSST_L4_MUR_Sea_Surface_Temperature` +
              `&STYLES=` +
              `&FORMAT=image/png` +
              `&TRANSPARENT=true` +
              `&WIDTH=${imageWidth}` +
              `&HEIGHT=${imageHeight}` +
              `&CRS=EPSG:4326` +
              `&BBOX=${bbox}` +
              `&TIME=${date}`;

            // Fetch the complete image
            const response = await fetch(wmsUrl);

            if (response.ok) {
              const blob = await response.blob();
              const imageDataUrl = await blobToBase64(blob);

              animationFrames.push({
                date: date,
                imageData: imageDataUrl, // Store image for current view as base64
                bounds: viewBounds,
                frameNumber: i + 1,
                totalFrames: dateArray.length
              });

              console.log(`✓ Image ${i + 1}/${dateArray.length} fetched (${(blob.size / 1024).toFixed(0)}KB): ${date}`);
            } else {
              console.warn(`✗ Image ${i + 1}/${dateArray.length} failed (HTTP ${response.status}): ${date}`);
            }
          } catch (error) {
            console.warn(`✗ Failed to fetch image for date ${date}:`, error.message);
          }

          // Update progress
          const progress = ((i + 1) / dateArray.length) * 100;
          if (progressFill) {
            progressFill.style.width = `${progress}%`;
          }

          // Update loading text
          const loadingText = document.getElementById('loadingText');
          if (loadingText) {
            loadingText.textContent = `Fetching image ${i + 1}/${dateArray.length}... (${Math.round(progress)}%)`;
          }

          // Small delay to prevent overwhelming the server
          await new Promise(resolve => setTimeout(resolve, 200));
        }

        console.log(`✓ Successfully fetched ${animationFrames.length}/${dateArray.length} images for current view`);

        if (animationFrames.length === 0) {
          updateStatus('No images available');
          alert('No valid images found for the selected date range. Please try a different date range.');
        } else {
          updateStatus(`✓ Animation Ready (${animationFrames.length} images)`);

          // Update frame count display
          const frameCountEl = document.getElementById('frameCount');
          if (frameCountEl) {
            const totalSize = animationFrames.reduce((sum, f) => sum + (f.imageData ? f.imageData.length : 0), 0);
            frameCountEl.textContent = `${animationFrames.length} images (${(totalSize / 1024 / 1024).toFixed(1)}MB) for current view`;
          }

          // Hide progress bar
          if (progressBar) {
            progressBar.classList.add('hidden');
          }

          alert(`Build complete! ${animationFrames.length} images loaded for current map view.\n⚠️ Don't zoom or pan during playback - images are optimized for this view!`);
        }

      } catch (error) {
        console.error('Error building animation:', error);
        updateStatus('Build Failed');
        alert('Failed to build animation. Please try again.');

        // Hide progress bar on error
        if (progressBar) {
          progressBar.classList.add('hidden');
        }
      } finally {
        hideLoading();
      }
    }

    // Play/Pause animation with pre-loaded static images
    function playAnimation() {
      if (animationFrames.length === 0) {
        alert('Please build the animation first by clicking "Build Animation".');
        return;
      }

      const playIcon = document.getElementById('playIcon');
      const pauseIcon = document.getElementById('pauseIcon');

      if (isPlaying) {
        // Pause animation
        if (animationInterval) {
          clearInterval(animationInterval);
          animationInterval = null;
        }
        isPlaying = false;
        updateStatus('Paused');

        // Re-enable map interactions when paused
        map.dragging.enable();
        map.touchZoom.enable();
        map.doubleClickZoom.enable();
        map.scrollWheelZoom.enable();
        map.boxZoom.enable();
        map.keyboard.enable();
        if (map.tap) map.tap.enable();

        // Update button icon
        if (playIcon && pauseIcon) {
          playIcon.classList.remove('hidden');
          pauseIcon.classList.add('hidden');
        }
        return;
      }

      // Restore map view to match when animation was built
      if (savedMapView) {
        map.setView(savedMapView.center, savedMapView.zoom, { animate: false });
        console.log(`✓ Restored map view to zoom ${savedMapView.zoom}, center [${savedMapView.center.lat.toFixed(2)}, ${savedMapView.center.lng.toFixed(2)}]`);
      }

      // Start playing
      isPlaying = true;
      currentFrameIndex = 0;
      updateStatus('Playing...');

      // Update button icon to pause
      if (playIcon && pauseIcon) {
        playIcon.classList.add('hidden');
        pauseIcon.classList.remove('hidden');
      }

      // Remove current SST overlay if exists
      if (sstLayer && map.hasLayer(sstLayer)) {
        map.removeLayer(sstLayer);
        sstLayer = null;
      }

      // Disable map interactions during playback for perfect alignment
      map.dragging.disable();
      map.touchZoom.disable();
      map.doubleClickZoom.disable();
      map.scrollWheelZoom.disable();
      map.boxZoom.disable();
      map.keyboard.disable();
      if (map.tap) map.tap.disable();

      animationInterval = setInterval(() => {
        if (currentFrameIndex >= animationFrames.length) {
          // Animation finished
          clearInterval(animationInterval);
          animationInterval = null;
          isPlaying = false;
          updateStatus('Animation Complete');

          // Re-enable map interactions
          map.dragging.enable();
          map.touchZoom.enable();
          map.doubleClickZoom.enable();
          map.scrollWheelZoom.enable();
          map.boxZoom.enable();
          map.keyboard.enable();
          if (map.tap) map.tap.enable();

          // Reset button icon
          if (playIcon && pauseIcon) {
            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');
          }
          return;
        }

        const frame = animationFrames[currentFrameIndex];

        // Remove previous overlay
        if (sstLayer && map.hasLayer(sstLayer)) {
          map.removeLayer(sstLayer);
        }

        // Display the pre-loaded GLOBAL high-res image as an overlay (INSTANT!)
        if (frame.imageData && frame.bounds) {
          // Use global bounds - image will scale automatically with map zoom
          const imageBounds = [
            [frame.bounds.south, frame.bounds.west],  // Southwest corner
            [frame.bounds.north, frame.bounds.east]   // Northeast corner
          ];

          sstLayer = L.imageOverlay(frame.imageData, imageBounds, {
            opacity: 0.8,
            interactive: false,
            className: 'sst-overlay-layer' // For potential CSS styling
          }).addTo(map);

          // Update frame count display
          const frameCountEl = document.getElementById('frameCount');
          if (frameCountEl) {
            frameCountEl.textContent = `Frame ${frame.frameNumber}/${frame.totalFrames} - ${frame.date}`;
          }

          console.log(`✓ INSTANT display frame ${currentFrameIndex + 1}/${animationFrames.length}: ${frame.date}`);
        }

        currentFrameIndex++;
      }, 500); // Fast playback since images are pre-loaded
    }

    // Stop animation and cleanup
    function stopAnimation() {
      if (animationInterval) {
        clearInterval(animationInterval);
        animationInterval = null;
      }
      isPlaying = false;

      // Re-enable map interactions
      if (map) {
        map.dragging.enable();
        map.touchZoom.enable();
        map.doubleClickZoom.enable();
        map.scrollWheelZoom.enable();
        map.boxZoom.enable();
        map.keyboard.enable();
        if (map.tap) map.tap.enable();
      }

      // Remove current SST layer
      if (sstLayer && map && map.hasLayer(sstLayer)) {
        map.removeLayer(sstLayer);
        sstLayer = null;
      }

      updateStatus('Stopped');
    }

    // Reset animation
    function resetAnimation() {
      stopAnimation();
      currentFrameIndex = 0;

      // Update frame count display
      const frameCountEl = document.getElementById('frameCount');
      if (frameCountEl) {
        if (animationFrames.length === 0) {
          frameCountEl.textContent = 'No images loaded';
        } else {
          const totalSize = animationFrames.reduce((sum, f) => sum + (f.imageData ? f.imageData.length : 0), 0);
          frameCountEl.textContent = `${animationFrames.length} images (${(totalSize / 1024 / 1024).toFixed(1)}MB) for current view`;
        }
      }

      // Reset button icon
      const playIcon = document.getElementById('playIcon');
      const pauseIcon = document.getElementById('pauseIcon');
      if (playIcon && pauseIcon) {
        playIcon.classList.remove('hidden');
        pauseIcon.classList.add('hidden');
      }

      updateStatus('Reset');
    }
    
    // Toggle SST Layer (for manual toggle, not animation)
    function toggleSST(enabled) {
      if (enabled) {
        if (!sstLayer) {
          sstLayer = L.tileLayer('https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/GHRSST_L4_MUR_Sea_Surface_Temperature/default/2024-09-15/GoogleMapsCompatible_Level7/{z}/{y}/{x}.png', {
            maxZoom: 7,
            opacity: 0.8,
            tileSize: 256
          });
        }
        sstLayer.addTo(map);
        updateStatus('SST Layer Enabled');
      } else {
        if (sstLayer && map.hasLayer(sstLayer)) {
          map.removeLayer(sstLayer);
          sstLayer = null;
        }
        updateStatus('SST Layer Disabled');
      }
    }
    
    // Update status
    function updateStatus(message) {
      const statusEl = document.getElementById('status');
      if (statusEl) statusEl.textContent = message;
    }
    
    // Show/hide loading
    function showLoading(text = 'Loading...') {
      const loader = document.getElementById('loadingIndicator');
      const loaderText = document.getElementById('loadingText');
      if (loader) {
        loader.classList.remove('hidden');
        if (loaderText) loaderText.textContent = text;
      }
    }
    
    function hideLoading() {
      const loader = document.getElementById('loadingIndicator');
      if (loader) loader.classList.add('hidden');
    }
    
    // Initialize on DOM ready
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize map
      initMap();
      
      // Set default dates
      const today = new Date();
      const pastDate = new Date(today);
      pastDate.setDate(today.getDate() - 21);
      
      document.getElementById('fromDate').value = pastDate.toISOString().split('T')[0];
      document.getElementById('toDate').value = today.toISOString().split('T')[0];
      
      // Layers panel toggle
      const layersBtn = document.getElementById('layersButton');
      const layersPanel = document.getElementById('layersPanel');
      const layersClose = document.getElementById('layersClose');
      
      layersBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        layersPanel.classList.toggle('hidden');
      });
      
      layersClose.addEventListener('click', () => {
        layersPanel.classList.add('hidden');
      });
      
      document.addEventListener('click', (e) => {
        if (!layersPanel.contains(e.target) && !layersBtn.contains(e.target)) {
          layersPanel.classList.add('hidden');
        }
      });
      
      // SST toggle
      document.getElementById('sstLayer').addEventListener('change', (e) => {
        toggleSST(e.target.checked);
      });
      
      // Button handlers
      document.getElementById('buildBtn').addEventListener('click', buildAnimation);

      document.getElementById('playBtn').addEventListener('click', playAnimation);

      document.getElementById('resetBtn').addEventListener('click', resetAnimation);
      
      document.getElementById('downloadBtn').addEventListener('click', () => {
        if (animationFrames.length === 0) {
          alert('Please build the animation first.');
          return;
        }

        // Create download data (excluding heavy base64 images from metadata)
        const animationData = {
          metadata: {
            totalFrames: animationFrames.length,
            dateRange: `${document.getElementById('fromDate').value} to ${document.getElementById('toDate').value}`,
            imageFormat: 'base64/png (static images)',
            fetchMethod: 'NASA GIBS WMS GetMap',
            created: new Date().toISOString()
          },
          frames: animationFrames.map(f => ({
            date: f.date,
            frameNumber: f.frameNumber,
            totalFrames: f.totalFrames,
            hasImageData: !!f.imageData,
            imageSizeBytes: f.imageData ? f.imageData.length : 0
          }))
        };

        const dataStr = JSON.stringify(animationData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);

        const link = document.createElement('a');
        link.href = url;
        link.download = `sst-animation-${Date.now()}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        updateStatus('Downloaded');
      });
    });
  </script>
</body>
</html>
